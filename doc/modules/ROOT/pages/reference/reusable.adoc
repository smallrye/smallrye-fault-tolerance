= Reusable Fault Tolerance

include::partial$srye-feature.adoc[]

The declarative, annotation-based API of {microprofile-fault-tolerance} doesn't allow sharing configuration of fault tolerance strategies across multiple classes.
In a single class, the configuration may be shared across all methods by putting the annotations on the class instead of individual methods, but even then, _stateful_ fault tolerance strategies are not shared.
Each method has its own bulkhead, circuit breaker and/or rate limit, which is often not what you want.

The xref:reference/programmatic-api.adoc[programmatic API] of {smallrye-fault-tolerance} allows using a single `Guard` or `TypedGuard` object to guard multiple disparate actions, which allows reuse and state sharing.
It is possible to use a programmatically constructed `Guard` or `TypedGuard` object declaratively, using the `@ApplyGuard` annotation.

To be able to do that, we need a bean of type `Guard` with the `@Identifier` qualifier:

[source,java]
----
@ApplicationScoped
public class PreconfiguredFaultTolerance {
    @Produces
    @Identifier("my-fault-tolerance")
    public static final Guard GUARD = Guard.create()
            .withRetry().maxRetries(2).done()
            .withTimeout().done()
            .build();
}
----

See the xref:reference/programmatic-api.adoc[programmatic API] documentation for more information about creating the `Guard` or `TypedGuard` instance.

It is customary to create the bean by declaring a `static` producer field, just like in the previous example.

Once we have that, we can apply `my-fault-tolerance` to any method:

[source,java]
----
@ApplicationScoped
public class MyService {
    @ApplyGuard("my-fault-tolerance")
    public String doSomething() {
        ...
    }

    @ApplyGuard("my-fault-tolerance")
    public CompletionStage<Integer> doSomethingElse() {
        ...
    }
}
----

Note that it is not possible to define a fallback on `Guard`, because fallback is tied to the action type.

It is also possible to create a bean of type `TypedGuard<>` and apply it to methods that return the type `TypedGuard` was created with.
Note that `TypedGuard` allows defining a fallback, because it can only be used to guard methods with a single return type.

== Metrics

Methods annotated `@ApplyGuard` gather metrics similarly to methods annotated with {microprofile-fault-tolerance} annotations.
That is, each method gets its own metrics, with the `method` tag being `<fully qualified class name>.<method name>`.

At the same time, state is still shared.
All methods annotated `@ApplyGuard` share the same bulkhead, circuit breaker and/or rate limit.

If the `Guard` or `TypedGuard` object used for `@ApplyGuard` is also used xref:reference/programmatic-api.adoc[programmatically], that usage is coalesced in metrics under the description as the `method` tag.

[[migration_from_applyfaulttolerance]]
== Migration from `@ApplyFaultTolerance`

The 1st version of the programmatic API had the `@ApplyFaultTolerance` annotation.
That annotation is deprecated and scheduled for removal in {smallrye-fault-tolerance} 7.0.

To migrate, replace `@ApplyFaultTolerance` with `@ApplyGuard` and change the `FaultTolerance<>` producers to produce `Guard` or `TypedGuard<>`.
See xref:reference/programmatic-api.adoc#migration_from_faulttolerance[the programmatic API migration guide] for more details about that.

Note that it is not possible to define both `Guard` and `TypedGuard<>` with the same identifier; that leads to a deployment problem.
Therefore, for each producer of `FaultTolerance<>`, you have to decide whether the replacement should be `Guard` or `TypedGuard<>`.
