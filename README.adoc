:microprofile-fault-tolerance: https://github.com/eclipse/microprofile-fault-tolerance/
:ci: https://github.com/smallrye/smallrye-fault-tolerance/actions?query=workflow%3A%22SmallRye+Build%22
:sonar: https://sonarcloud.io/dashboard?id=smallrye_smallrye-fault-tolerance

image:https://github.com/smallrye/smallrye-fault-tolerance/workflows/SmallRye%20Build/badge.svg?branch=master[link={ci}]
image:https://sonarcloud.io/api/project_badges/measure?project=smallrye_smallrye-fault-tolerance&metric=alert_status["Quality Gate Status", link={sonar}]
image:https://img.shields.io/github/license/smallrye/smallrye-fault-tolerance.svg["License", link="http://www.apache.org/licenses/LICENSE-2.0"]
image:https://img.shields.io/maven-central/v/io.smallrye/smallrye-fault-tolerance?color=green[]

== SmallRye Fault Tolerance

SmallRye Fault Tolerance is an implementation of {microprofile-fault-tolerance}[Eclipse MicroProfile Fault Tolerance].

=== API

SmallRye Fault Tolerance provides some additional APIs on top of MicroProfile Fault Tolerance.
Before proper documentation exists, please refer to the `api` directory directly.

==== @Blocking and @NonBlocking

In addition to the MicroProfile Fault Tolerance `@Asynchronous` annotation, which can be placed on methods returning `Future` or `CompletionStage`, SmallRye Fault Tolerance also supports 2 more annotations for asynchronous processing:

* `@io.smallrye.common.annotation.Blocking`
* `@io.smallrye.common.annotation.NonBlocking`

These annotations can have multiple meanings, depending on context.
SmallRye Fault Tolerance only pays attention to these annotations if:

* they are placed on methods that return `CompletionStage` (the `Future` type can't really be used for non-blocking processing);
* they are placed on methods that apply some fault tolerance strategy (such as `@Fallback`, defined either on a method or a class).

Under these circumstances, SmallRye Fault Tolerance assigns these annotations the following meaning:

* `@Blocking` means that execution of the operation will be offloaded to another thread (that's what `@Asynchronous` does by default).
  Use this annotation if the method has blocking logic, but you don't want to block the caller thread.
** The thread pool that is used for offloading method calls is the one provided by the runtime that integrates SmallRye Fault Tolerance.
   See below for more info.
* `@NonBlocking` means that the execution of the operation will _not_ be offloaded to another thread (even if the method is annotated `@Asynchronous`).
  Use this annotation if the method _doesn't_ have blocking logic and you want the execution to stay on the caller thread.
** Note that if the guarded method also uses `@Retry` and some delay between retries is configured, only the initial execution will occur on the original thread.
   Subsequent attempts will be offloaded to an extra thread, so that the original thread is not blocked on the delay.

===== Rationale

We believe that the `@Asynchronous` annotation is misnamed, because its meaning is "offload execution to another thread".
This isn't always appropriate in modern asynchronous programming, where methods are often non-blocking and thread offload is not required.
We believe that declaring whether the method blocks or not is a better aproach.

At the same time, we designed these annotations to be used by a variety of frameworks, so SmallRye Fault Tolerance can't eagerly intercept all methods using them.
We also want to stay compatible with the MicroProfile Fault Tolerance specification as much as possible.
For these reasons, SmallRye Fault Tolerance only considers these annotations for methods that use some fault tolerance strategy.

===== Recommendation

For methods that use fault tolerance and return `CompletionStage`, we recommend to declare their `@Blocking` or `@NonBlocking` nature.
In such case, the `@Asynchronous` annotation becomes optional.

We also recommend to avoid `@Asynchronous` methods that return `Future`, because the only way to obtain the future value is blocking.

==== Additional asynchronous types

MicroProfile Fault Tolerance supports asynchronous fault tolerance for methods that return `CompletionStage`.
(The `Future` type is not truly asynchronous, so we won't take it into account here.)
SmallRye Fault Tolerance adds support for additional asynchronous types:

* Mutiny: `Uni`
* RxJava: `Single`, `Maybe`, `Completable`
* Reactor: `Mono`

These types are treated just like `CompletionStage`, so everything that works for `CompletionStage` works for these types as well.
Stream-like types (`Multi`, `Observable`, `Flowable`, `Flux`) are not supported, because their semantics can't be easily expressed in terms of `CompletionStage`.

The implementation is based on the https://github.com/smallrye/smallrye-reactive-utils/tree/master/reactive-converters[SmallRye Reactive Converters] project.
For each library, add the corresponding converter dependency:

* https://smallrye.io/smallrye-mutiny/[Mutiny]: `io.smallrye.reactive:smallrye-reactive-converter-mutiny`
* https://github.com/ReactiveX/RxJava/tree/1.x[RxJava 1]: `io.smallrye.reactive:smallrye-reactive-converter-rxjava1`
* https://github.com/ReactiveX/RxJava/tree/2.x[RxJava 2]: `io.smallrye.reactive:smallrye-reactive-converter-rxjava2`
* https://github.com/ReactiveX/RxJava/tree/3.x[RxJava 3]: `io.smallrye.reactive:smallrye-reactive-converter-rxjava3`
* https://projectreactor.io/[Reactor]: `io.smallrye.reactive:smallrye-reactive-converter-reactor`

If you use SmallRye Fault Tolerance integrated in some runtime, it's possible that the runtime already provides the correct integration.

=== Integration

==== Thread pool

SmallRye Fault Tolerance expects integrators to provide a thread pool for running `@Asynchronous` methods and other asynchronous tasks.
The integration is based on CDI; see `io.smallrye.faulttolerance.AsyncExecutorProvider` and `io.smallrye.faulttolerance.DefaultAsyncExecutorProvider` for details.

There is a default thread pool in case no integration is provided, but it shouldn't be used outside of tests or experiments.

==== Context Propagation

SmallRye Fault Tolerance supports MicroProfile Context Propagation, if 2 conditions are satistied:

- the integrator provides a MicroProfile Context Propagation enabled thread pool (see above);
- the `smallrye-fault-tolerance-context-propagation` artifact is present (it provides alternative implementations of some internal services).

==== OpenTracing

SmallRye Fault Tolerance includes an integration between MicroProfile Context Propagation and OpenTracing.
It is the `smallrye-fault-tolerance-tracing-propagation` artifact.

Technically, this doesn't even belong to SmallRye Fault Tolerance.

=== Configuration

SmallRye Fault Tolerance supports all the configuration options of MicroProfile Fault Tolerance.
This includes both annotations and `.properties` configuration.

If SmallRye Fault Tolerance integrator doesn't provide a thread pool, the default thread pool is used and the following configuration properties are also recongized:

- `io.smallrye.faulttolerance.mainThreadPoolSize`: maximum number of threads in the fault tolerance thread pool.
  Defaults to `100`.

- `io.smallrye.faulttolerance.mainThreadPoolQueueSize`: size of the queue that the thread pool should use.
  Can be `> 0`, in which case the queue will be bounded to given size.
  Can be `0`, in which case there will be no queue and the thread pool will reject excess tasks.
  Can be `-1`, in which case the queue will be unbounded.
  Values `< -1` are an error.
  Defaults to `-1`.

Older configuration properties that should no longer be used:

- `io.smallrye.faulttolerance.globalThreadPoolSize`: deprecated; use `mainThreadPoolSize` instead.
  If `mainThreadPoolSize` isn't set, this is still used as a fallback.

- `io.smallrye.faulttolerance.timeoutExecutorThreads`: ignored.
  Was previously used to set size of a dedicated thread pool for timeout watchers.
  No longer used, because timeout watchers are now executed on the main thread pool.

=== Instructions

Compile and install this project:

[source,bash]
----
mvn clean install
----

This will run all the tests and the TCK.

==== Project structure

* link:api[]:  SmallRye Fault Tolerance API, additional to the Eclipse MicroProfile Fault Tolerance API.
  Treated as a public API.
* link:implementation/core[]: Implementation of core fault tolerance strategies.
  Independent of the Eclipse MicroProfile Fault Tolerance API or the SmallRye Fault Tolerance API.
  Treated as private API, no compatibility guaranteed.
* link:implementation/fault-tolerance[]: Implementation of the Eclipse MicroProfile Fault Tolerance API and the SmallRye Fault Tolerance API.
* link:implementation/context-propagation[]: Optional integration with MicroProfile Context Propagation.
* link:implementation/tracing-propagation[]: Optional integration between MicroProfile Context Propagation and OpenTracing.
* link:testsuite/basic[]: Basic test suite.
  Some parts of it overlap with the Eclipse MicroProfile Fault Tolerance TCK.
* link:testsuite/integration[]: Context propagation integration test suite.
* link:testsuite/tck[]: Runs the implementation against the Eclipse MicroProfile Fault Tolerance TCK.
* link:docs[]: Where documentation should live.
  Currently, there is none, unfortunately.

==== Links

* http://github.com/smallrye/smallrye-fault-tolerance/[Project Homepage]
* {microprofile-fault-tolerance}[Eclipse MicroProfile Fault Tolerance]
